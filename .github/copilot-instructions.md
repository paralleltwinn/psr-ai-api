# GitHub Copilot Instructions for Poornasree AI Authentication System

## üèóÔ∏è Project Overview

This is a **comprehensive FastAPI authentication system** with role-based access control, built for **Poornasree AI**. The system provides secure user management, OTP verification, email services, and admin functionality.

## üìÅ Project Structure

```
psr-ai-api/
‚îú‚îÄ‚îÄ app/                          # Main application package
‚îÇ   ‚îú‚îÄ‚îÄ api/                      # API layer
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas.py           # Pydantic request/response models
‚îÇ   ‚îú‚îÄ‚îÄ auth/                     # Authentication logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py              # Password hashing, JWT tokens, OTP
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py      # Auth dependencies & middleware
‚îÇ   ‚îú‚îÄ‚îÄ core/                     # Core utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants.py         # Enums (UserRole, UserStatus, etc.)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.py           # Logging configuration
‚îÇ   ‚îú‚îÄ‚îÄ database/                 # Database layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.py          # SQLAlchemy setup & session management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.py            # Database models (User, OTP, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ routers/                  # API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py              # Authentication endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.py             # Admin management endpoints
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.py             # User profile endpoints
‚îÇ   ‚îú‚îÄ‚îÄ services/                 # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email_service.py     # Email/SMTP service
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_service.py      # User business logic
‚îÇ   ‚îú‚îÄ‚îÄ templates/                # HTML templates
‚îÇ   ‚îî‚îÄ‚îÄ config.py                # Configuration management
‚îú‚îÄ‚îÄ alembic/                      # Database migrations
‚îú‚îÄ‚îÄ logs/                         # Application logs
‚îú‚îÄ‚îÄ main.py                       # FastAPI application entry point
‚îú‚îÄ‚îÄ init.py                       # Database setup script
‚îú‚îÄ‚îÄ system_check.py               # System status verification
‚îî‚îÄ‚îÄ requirements.txt              # Python dependencies
```

## üéØ Key Technologies & Patterns

### **Framework & Architecture**
- **FastAPI** - Modern async web framework
- **SQLAlchemy** - ORM with async support
- **Alembic** - Database migrations
- **Pydantic** - Data validation & serialization
- **MySQL** - Primary database
- **Redis** - Caching layer

### **Authentication & Security**
- **JWT Tokens** - Bearer token authentication
- **bcrypt** - Password hashing
- **OTP Verification** - Email-based 2FA
- **Role-Based Access Control** - SUPER_ADMIN, ADMIN, ENGINEER, CUSTOMER
- **Rate Limiting** - Protection against brute force
- **Audit Logging** - Complete activity tracking

### **Design Patterns**
- **Repository Pattern** - Data access abstraction
- **Service Layer** - Business logic separation
- **Dependency Injection** - FastAPI dependencies
- **Factory Pattern** - Database session creation
- **Strategy Pattern** - Multiple authentication methods

## üîë Core Components

### **Database Models**
```python
# User roles and statuses
UserRole: SUPER_ADMIN | ADMIN | ENGINEER | CUSTOMER
UserStatus: PENDING | APPROVED | REJECTED | ACTIVE | INACTIVE | SUSPENDED

# Primary models
User                  # Main user entity
OTPVerification      # Email verification codes
EngineerApplication  # Engineer approval workflow
Notification         # In-app notifications
AuditLog            # Security audit trail
LoginAttempt        # Failed login tracking
```

### **Authentication Flow**
1. **Registration** ‚Üí Email OTP ‚Üí Account creation
2. **Login** ‚Üí Password/OTP ‚Üí JWT token
3. **Authorization** ‚Üí Bearer token ‚Üí Role checking
4. **Engineer Application** ‚Üí Admin review ‚Üí Approval/rejection

### **API Structure**
```
/api/v1/auth/*        # Public authentication endpoints
/api/v1/admin/*       # Admin-only management endpoints  
/api/v1/users/*       # User profile & notification endpoints
/health               # System health check
/docs                 # Swagger documentation
```

## üìù Coding Guidelines

### **File Naming & Organization**
- Use snake_case for Python files
- Group related functionality in modules
- Separate concerns: routers ‚Üí services ‚Üí models
- Keep routers thin, business logic in services

### **Import Structure**
```python
# Standard library imports
from datetime import datetime
from typing import Optional, List

# Third-party imports  
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

# Local imports
from ..api import schemas
from ..services import user_service
from ..database.models import User
from ..core.constants import UserRole
```

### **Error Handling**
```python
# Use FastAPI HTTPException for API errors
raise HTTPException(
    status_code=status.HTTP_400_BAD_REQUEST,
    detail="Descriptive error message"
)

# Use try/catch for service layer
try:
    result = await some_operation()
except SomeException as e:
    logger.error(f"Operation failed: {e}")
    raise HTTPException(status_code=500, detail="Internal server error")
```

### **Database Operations**
```python
# Always use dependency injection for DB sessions
def some_endpoint(db: Session = Depends(get_db)):
    user = user_service.get_user_by_email(db, email)
    
# Use service layer for complex queries
def get_active_users(db: Session) -> List[User]:
    return db.query(User).filter(
        User.is_active == True,
        User.status == UserStatus.ACTIVE
    ).all()
```

### **Response Models**
```python
# Always define Pydantic schemas for responses
@router.get("/users", response_model=schemas.UserListResponse)
async def get_users():
    # Implementation
    
# Use examples in schemas
class LoginRequest(BaseSchema):
    email: EmailStr = Field(..., example="official.tishnu@gmail.com")
    password: str = Field(..., example="Access@404")
```

## üîê Authentication Patterns

### **Role-Based Decorators**
```python
# Use dependencies for role checking
@router.get("/admin/dashboard")
async def get_dashboard(
    current_user: User = Depends(require_super_admin)
):
    # Only SUPER_ADMIN can access
```

### **JWT Token Handling**
```python
# Token creation
access_token = auth.create_access_token(
    data={"sub": user.email}, 
    expires_delta=timedelta(minutes=30)
)

# Token validation
current_user = get_current_user(token)
```

### **OTP Verification**
```python
# Generate OTP for email verification
otp_code = generate_otp()
send_verification_email(email, otp_code)

# Verify OTP before account creation
verify_otp(email, otp_code, purpose="registration")
```

## üìß Email Service Patterns

### **HTML Email Templates**
```python
# Use HTML templates for professional emails
template = f"""
<div style="font-family: Arial, sans-serif;">
    <h2>Welcome to Poornasree AI</h2>
    <p>Your verification code: <strong>{otp_code}</strong></p>
</div>
"""
```

### **Email Types**
- **Verification** - Account email confirmation
- **Welcome** - New user onboarding
- **Application** - Engineer application status
- **Notification** - System alerts

## üõ°Ô∏è Security Best Practices

### **Input Validation**
```python
# Always validate input with Pydantic
class UserCreate(BaseSchema):
    email: EmailStr = Field(..., description="Valid email address")
    password: str = Field(..., min_length=8, pattern=r"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)")
```

### **Password Security**
```python
# Use bcrypt for password hashing
hashed_password = get_password_hash(plain_password)
is_valid = verify_password(plain_password, hashed_password)
```

### **Rate Limiting & Audit**
```python
# Track login attempts
login_attempt = LoginAttempt(
    email=email,
    ip_address=request.client.host,
    success=success,
    failure_reason=reason if not success else None
)

# Log important actions
audit_log = AuditLog(
    user_id=current_user.id,
    action="USER_CREATED",
    entity_type="User",
    details=f"Created user {new_user.email}"
)
```

## üß™ Testing Patterns

### **Endpoint Testing**
```python
# Test authentication endpoints
def test_login_success():
    response = client.post("/api/v1/auth/login", json={
        "email": "official.tishnu@gmail.com",
        "password": "Access@404"
    })
    assert response.status_code == 200
    assert "access_token" in response.json()
```

### **Database Testing**
```python
# Use test database for isolation
@pytest.fixture
def test_db():
    # Create test database session
    # Run tests
    # Cleanup
```

## üìä Documentation Standards

### **Swagger Documentation**
```python
@router.post("/login", response_model=schemas.LoginResponse)
async def login(login_data: schemas.LoginRequest):
    """
    ## üîë User Login
    
    Authenticate user with email and password.
    
    **Example:**
    ```json
    {
      "email": "official.tishnu@gmail.com", 
      "password": "Access@404"
    }
    ```
    """
```

### **Code Comments**
```python
# Use descriptive comments for complex logic
def complex_business_logic():
    """
    Handle complex user approval workflow.
    
    Steps:
    1. Validate engineer application
    2. Check admin permissions  
    3. Update user status
    4. Send notification email
    5. Log audit trail
    """
```

## üöÄ Deployment & Operations

### **Environment Configuration**
```python
# Use .env for configuration
DATABASE_URL=mysql+pymysql://user:pass@localhost:3306/poornasree_ai
SECRET_KEY=your-secret-key
SMTP_HOST=smtp.gmail.com
```

### **Database Management**
```python
# Use Alembic for migrations
alembic revision --autogenerate -m "Add new table"
alembic upgrade head

# Use init.py for initial setup
python init.py  # Create database, tables, super admin
```

### **Monitoring & Health**
```python
# Health check endpoint
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "version": settings.app_version,
        "database": "connected"
    }
```

## üîß Development Workflow

### **Adding New Features**
1. **Define Schema** ‚Üí Add Pydantic models in `schemas.py`
2. **Create Database Model** ‚Üí Add SQLAlchemy model in `models.py`
3. **Implement Service** ‚Üí Add business logic in appropriate service
4. **Create Router** ‚Üí Add API endpoints with proper documentation
5. **Add Tests** ‚Üí Write comprehensive tests
6. **Update Documentation** ‚Üí Update API docs and README

### **Code Review Checklist**
- ‚úÖ Proper error handling with descriptive messages
- ‚úÖ Input validation with Pydantic schemas
- ‚úÖ Authentication/authorization checks
- ‚úÖ Swagger documentation with examples
- ‚úÖ Database operations use service layer
- ‚úÖ Sensitive data not logged
- ‚úÖ Rate limiting considered
- ‚úÖ Audit logging for important actions

## üéØ Common Patterns to Follow

### **Service Layer Pattern**
```python
# user_service.py
def create_user(db: Session, user_data: UserCreate) -> User:
    """Create new user with proper validation."""
    # Business logic here
    
# auth.py router
@router.post("/register")
async def register(user_data: UserCreate, db: Session = Depends(get_db)):
    return user_service.create_user(db, user_data)
```

### **Dependency Injection**
```python
# dependencies.py
async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    # Token validation logic
    
async def require_admin(current_user: User = Depends(get_current_user)) -> User:
    if current_user.role not in [UserRole.ADMIN, UserRole.SUPER_ADMIN]:
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user
```

### **Response Consistency**
```python
# Always use consistent response formats
{
    "success": true,
    "data": { ... },
    "message": "Operation successful"
}

# For errors
{
    "success": false, 
    "error": "Error description",
    "code": "ERROR_CODE"
}
```

---

## üéâ Project Goals

This authentication system provides:
- üîê **Secure Authentication** - JWT + OTP + Role-based access
- üë• **User Management** - Complete lifecycle management
- üìß **Email Integration** - Professional email communications  
- ‚öôÔ∏è **Admin Dashboard** - Comprehensive system management
- üìä **Audit & Monitoring** - Complete activity tracking
- üöÄ **Scalable Architecture** - Clean, maintainable codebase

**Remember**: Always prioritize security, maintainability, and comprehensive documentation in your code!
